<?php

/**
 * @file
 * Primary module hooks for Rating Scorer module.
 */

use Drupal\Core\Link;
use Drupal\Core\Url;

/**
 * Implements hook_help().
 */
function rating_scorer_help($route_name, $route_match) {
  switch ($route_name) {
    case 'help.page.rating_scorer':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The Rating Scorer module provides a calculator for combining ratings and number of ratings using various scoring methods.') . '</p>';
      $output .= '<h3>' . t('Uses') . '</h3>';
      $output .= '<dl>';
      $output .= '<dt>' . t('Calculating scores') . '</dt>';
      $output .= '<dd>' . t('Use the calculator at <a href=":calculator">Rating Scorer</a> to see how different scoring methods combine rating values with the number of ratings.', [':calculator' => '/admin/config/rating-scorer']) . '</dd>';
      $output .= '<dt>' . t('Configuring defaults') . '</dt>';
      $output .= '<dd>' . t('Users with the "Administer rating scorer settings" permission can configure default parameters at <a href=":settings">Rating Scorer Settings</a>.', [':settings' => '/admin/config/rating-scorer/settings']) . '</dd>';
      $output .= '</dl>';
      return $output;
  }
}

/**
 * Implements hook_theme().
 */
function rating_scorer_theme($existing, $type, $theme, $path) {
  return [
    'rating_scorer' => [
      'variables' => [],
      'template' => 'rating-scorer',
    ],
    'rating_scorer_dashboard' => [
      'variables' => [
        'statistics' => [],
        'field_mappings' => [],
      ],
      'template' => 'rating-scorer-dashboard',
    ],
  ];
}

/**
 * Implements hook_entity_presave().
 *
 * Automatically calculates and updates rating score fields when content
 * entities are saved. This hook is triggered before an entity is saved to
 * the database, allowing the module to recalculate scores based on current
 * rating data.
 *
 * The hook only processes content entities that have field mappings configured.
 * It uses the RatingScoreCalculator service to determine if the entity has
 * rating score fields and updates them with freshly calculated values.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity being saved. Must be a ContentEntityInterface to be processed.
 *   Non-content entities (like configuration entities) are ignored.
 *
 * @return void
 *   This hook does not return a value.
 *
 * @throws \Exception
 *   May throw exceptions during score calculation, which are caught and logged.
 *
 * @see \Drupal\rating_scorer\Service\RatingScoreCalculator::updateScoreFieldsOnEntity()
 *
 * Example usage by other modules:
 * @code
 * // Other modules can implement this hook to react to entity saves
 * function mymodule_entity_presave(\Drupal\Core\Entity\EntityInterface $entity) {
 *   // React to entities before Rating Scorer calculates scores
 *   if ($entity->getEntityTypeId() === 'node') {
 *     // Custom logic before score calculation
 *   }
 * }
 * @endcode
 */
function rating_scorer_entity_presave(\Drupal\Core\Entity\EntityInterface $entity) {
  if (!($entity instanceof \Drupal\Core\Entity\ContentEntityInterface)) {
    return;
  }

  try {
    $calculator = \Drupal::service('rating_scorer.calculator');
    $calculator->updateScoreFieldsOnEntity($entity);

    // Log when scores are updated for debugging
    \Drupal::logger('rating_scorer')->info(
      'Updated rating scores for @type (@bundle)',
      [
        '@type' => $entity->getEntityTypeId(),
        '@bundle' => $entity->bundle(),
      ]
    );
  } catch (\Exception $e) {
    // Log errors for debugging
    \Drupal::logger('rating_scorer')->error(
      'Error updating rating scores: @error',
      ['@error' => $e->getMessage()]
    );
  }
}

/**
 * Helper function to calculate a rating score.
 *
 * @param int $number_of_ratings
 *   The number of ratings.
 * @param float $average_rating
 *   The average rating.
 * @param string $method
 *   The scoring method.
 * @param int $minimum_threshold
 *   The minimum ratings threshold.
 *
 * @return float
 *   The calculated score.
 */
function _rating_scorer_calculate_score($number_of_ratings, $average_rating, $method, $minimum_threshold) {
  switch ($method) {
    case 'bayesian':
      $prior_rating = 2.5;
      return ($number_of_ratings * $average_rating + $minimum_threshold * $prior_rating) / ($number_of_ratings + $minimum_threshold);

    case 'wilson':
      $normalized_rating = $average_rating / 5;
      $z = 1.96;
      if ($number_of_ratings == 0) {
        return 0;
      }
      $phat = $normalized_rating;
      $denominator = 1 + $z * $z / $number_of_ratings;
      $center = ($phat + $z * $z / (2 * $number_of_ratings)) / $denominator;
      $margin = $z * sqrt(($phat * (1 - $phat) / $number_of_ratings) + ($z * $z / (4 * $number_of_ratings * $number_of_ratings))) / $denominator;
      return max(0, $center - $margin);

    case 'weighted':
    default:
      return $average_rating * log($number_of_ratings + 1);
  }
}

/**
 * Implements hook_views_pre_render().
 *
 * Handles sorting of Views results by rating score fields. This hook is
 * triggered after the view query has been executed but before the results
 * are rendered, allowing modification of the result set.
 *
 * The hook specifically looks for:
 * - Views with rating_score sort criteria
 * - Views with rating_score field handlers
 * - Views that have actual results to sort
 *
 * When found, it ensures all rating scores are calculated by rendering the
 * field, then sorts the results in memory according to the configured sort
 * order (ASC/DESC).
 *
 * @param \Drupal\views\ViewExecutable $view
 *   The view object being rendered. Contains the query results, field handlers,
 *   and sort criteria that will be processed for rating score sorting.
 *
 * @return void
 *   This hook does not return a value. It modifies the $view object directly
 *   by reordering the $view->result array.
 *
 * @see \Drupal\views\ViewExecutable
 * @see \Drupal\rating_scorer\Plugin\Field\FieldType\RatingScoreItem
 *
 * Example usage by other modules:
 * @code
 * // Other modules can implement this hook to modify view results
 * function mymodule_views_pre_render(\Drupal\views\ViewExecutable $view) {
 *   if ($view->id() === 'my_view_with_ratings') {
 *     // Custom sorting or filtering logic
 *     foreach ($view->result as $row) {
 *       // Modify result data
 *     }
 *   }
 * }
 * @endcode
 */
function rating_scorer_views_pre_render(\Drupal\views\ViewExecutable $view) {
  // Check if the view has rating_score sort criteria.
  if (empty($view->sort) || empty($view->result)) {
    return;
  }

  $rating_score_sort = NULL;
  foreach ($view->sort as $sort) {
    if ($sort->getPluginId() === 'rating_score') {
      $rating_score_sort = $sort;
      break;
    }
  }

  if (!$rating_score_sort) {
    return;
  }

  // Find the rating_score field handler.
  $field_handler = NULL;
  foreach ($view->field as $field) {
    if ($field->getPluginId() === 'rating_score') {
      $field_handler = $field;
      break;
    }
  }

  if (!$field_handler) {
    return;
  }

  // Ensure all rows have their scores cached by rendering the field.
  foreach ($view->result as $row) {
    $field_handler->render($row);
  }

  // Sort the current page results based on cached scores.
  usort($view->result, function ($a, $b) use ($rating_score_sort) {
    $score_a = $a->rating_score_value ?? 0;
    $score_b = $b->rating_score_value ?? 0;

    $result = $score_a <=> $score_b;

    // Reverse if descending order.
    if ($rating_score_sort->options['order'] === 'DESC') {
      $result = -$result;
    }

    return $result;
  });
}

/**
 * Implements hook_entity_update().
 *
 * Triggers mass recalculation of rating scores when field mapping
 * configuration entities are updated. This ensures that changes to scoring
 * algorithms, field mappings, or thresholds are immediately applied to all
 * existing content.
 *
 * The hook specifically processes updates to 'rating_scorer_field_mapping'
 * configuration entities. When such an entity is updated, it:
 * 1. Extracts the affected content type from the mapping ID
 * 2. Loads all entities of that content type
 * 3. Recalculates and saves updated scores for each entity
 * 4. Logs the number of entities updated
 *
 * This process can be resource-intensive for content types with many entities.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity being updated. Only rating_scorer_field_mapping entities
 *   trigger the recalculation process. Other entity types are ignored.
 *
 * @return void
 *   This hook does not return a value.
 *
 * @throws \Exception
 *   May throw exceptions during entity loading or score calculation.
 *   Exceptions are logged but do not prevent the update process.
 *
 * @see \Drupal\rating_scorer\Entity\RatingScorerFieldMapping
 * @see \Drupal\rating_scorer\Service\RatingScoreCalculator::updateScoreFieldsOnEntity()
 *
 * Example usage by other modules:
 * @code
 * // Other modules can implement this hook to react to entity updates
 * function mymodule_entity_update(\Drupal\Core\Entity\EntityInterface $entity) {
 *   if ($entity->getEntityTypeId() === 'rating_scorer_field_mapping') {
 *     // React to field mapping changes
 *     \Drupal::logger('mymodule')->info('Rating mapping updated: @id', [
 *       '@id' => $entity->id(),
 *     ]);
 *   }
 * }
 * @endcode
 */
function rating_scorer_entity_update(Drupal\Core\Entity\EntityInterface $entity) {
  if ($entity->getEntityTypeId() !== 'rating_scorer_field_mapping') {
    return;
  }

  // Extract content type from config ID (format: "node_{bundle}").
  $id_parts = explode('_', $entity->id());
  if (count($id_parts) !== 2 || $id_parts[0] !== 'node') {
    return;
  }

  $bundle = $id_parts[1];
  $entity_type_manager = \Drupal::entityTypeManager();
  $calculator = \Drupal::service('rating_scorer.calculator');
  $logger = \Drupal::logger('rating_scorer');

  // Load all nodes of the affected content type.
  $nids = $entity_type_manager
    ->getStorage('node')
    ->getQuery()
    ->accessCheck(FALSE)
    ->condition('type', $bundle)
    ->execute();

  if (empty($nids)) {
    return;
  }

  $nodes = $entity_type_manager->getStorage('node')->loadMultiple($nids);
  $recalculated = 0;

  // Recalculate scores for each node.
  foreach ($nodes as $node) {
    $calculator->updateScoreFieldsOnEntity($node);
    $node->save();
    $recalculated++;
  }

  if ($recalculated > 0) {
    $logger->info('Recalculated rating scores for @count nodes of type @bundle', [
      '@count' => $recalculated,
      '@bundle' => $bundle,
    ]);
  }
}
